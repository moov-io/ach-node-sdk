/* tslint:disable */
/* eslint-disable */
/**
 * ACH API
 * Moov ACH ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing, and validating ACH files. ACH is the primary method of electronic money movement throughout the United States.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ADVBatchControl
 */
export interface ADVBatchControl {
    /**
     * Batch ID
     * @type {string}
     * @memberof ADVBatchControl
     */
    'id'?: string;
    /**
     * Same as ServiceClassCode in BatchHeader record
     * @type {number}
     * @memberof ADVBatchControl
     */
    'serviceClassCode': number;
    /**
     * EntryAddendaCount is a tally of each Entry Detail Record and each Addenda Record processed, within either the batch or file as appropriate.
     * @type {number}
     * @memberof ADVBatchControl
     */
    'entryAddendaCount': number;
    /**
     * Validate the Receiving DFI Identification in each Entry Detail Record is hashed to provide a check against inadvertent alteration of data contents due to hardware failure or program error. In this context the Entry Hash is the sum of the corresponding fields in the Entry Detail Records on the file. 
     * @type {number}
     * @memberof ADVBatchControl
     */
    'entryHash': number;
    /**
     * Contains accumulated Entry debit totals within the batch.
     * @type {number}
     * @memberof ADVBatchControl
     */
    'totalDebit': number;
    /**
     * Contains accumulated Entry credit totals within the batch.
     * @type {number}
     * @memberof ADVBatchControl
     */
    'totalCredit': number;
    /**
     * Alphanumeric code used to identify an ACH Operator
     * @type {string}
     * @memberof ADVBatchControl
     */
    'achOperatorData': string;
    /**
     * The routing number is used to identify the DFI originating entries within a given branch.
     * @type {string}
     * @memberof ADVBatchControl
     */
    'ODFIIdentification': string;
    /**
     * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record.
     * @type {number}
     * @memberof ADVBatchControl
     */
    'batchNumber': number;
}
/**
 * 
 * @export
 * @interface ADVEntryDetail
 */
export interface ADVEntryDetail {
    /**
     * Entry Detail ID
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'id'?: string;
    /**
     * TransactionCode representing Accounting Entries: 81 - Credit for ACH debits originated | 82 - Debit for ACH credits originated | 83 - Credit for ACH credits received | 84 - Debit for ACH debits received | 85 - Credit for ACH credits in rejected batches | 86 - Debit for ACH debits in rejected batches | 87 - Summary credit for respondent ACH activity | 88 - Summary debit for respondent ACH activity 
     * @type {number}
     * @memberof ADVEntryDetail
     */
    'transactionCode': number;
    /**
     * RDFI\'s routing number without the last digit.
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'RDFIIdentification': string;
    /**
     * Last digit in RDFI routing number.
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'checkDigit': string;
    /**
     * The receiver\'s bank account number you are crediting/debiting. It important to note that this is an alphanumeric field, so it\'s space padded, not zero padded 
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'DFIAccountNumber': string;
    /**
     * Number of cents you are debiting/crediting this account
     * @type {number}
     * @memberof ADVEntryDetail
     */
    'amount': number;
    /**
     * Suggested routing number to use
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'adviceRoutingNumber': string;
    /**
     * Unique identifier for the File
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'fileIdentification'?: string;
    /**
     * Information related to the ACH opreator
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'achOperatorData'?: string;
    /**
     * The name of the receiver, usually the name on the bank account
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'individualName': string;
    /**
     * DiscretionaryData allows ODFIs to include codes, of significance only to them, to enable specialized handling of the entry. There will be no standardized interpretation for the value of this field. It can either be a single two-character code, or two distinct one-character codes, according to the needs of the ODFI and/or Originator involved. This field must be returned intact for any returned entry. WEB uses the Discretionary Data Field as the Payment Type Code. 
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'discretionaryData'?: string;
    /**
     * AddendaRecordIndicator indicates the existence of an Addenda Record. A value of \"1\" indicates that one or more addenda records follow, and \"0\" means no such record is present. 
     * @type {number}
     * @memberof ADVEntryDetail
     */
    'addendaRecordIndicator'?: number;
    /**
     * Routing number for ACH Operator
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'achOperatorRoutingNumber': string;
    /**
     * Julian Day of the year
     * @type {number}
     * @memberof ADVEntryDetail
     */
    'julianDay'?: number;
    /**
     * SequenceNumber is consecutively assigned to each Addenda05 Record following an Entry Detail Record. The first Addenda05 sequence number must always be a 1.
     * @type {number}
     * @memberof ADVEntryDetail
     */
    'sequenceNumber': number;
    /**
     * Addenda99 record for the ADV Entry Detail
     * @type {Array<Addenda99>}
     * @memberof ADVEntryDetail
     */
    'addenda99'?: Array<Addenda99>;
    /**
     * Category defines if the entry is a Forward, Return, or NOC
     * @type {string}
     * @memberof ADVEntryDetail
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface ADVFileControl
 */
export interface ADVFileControl {
    /**
     * ADV File Control Record
     * @type {string}
     * @memberof ADVFileControl
     */
    'id'?: string;
    /**
     * Count of Batches in the File
     * @type {number}
     * @memberof ADVFileControl
     */
    'batchCount': number;
    /**
     * Total number of records in the file (include all headers and trailer) divided by 10 (This number must be evenly divisible by 10. If not, additional records consisting of all 9\'s are added to the file after the initial \'9\' record to fill out the block 10.) 
     * @type {number}
     * @memberof ADVFileControl
     */
    'blockCount': number;
    /**
     * Total detail and addenda records in the file
     * @type {number}
     * @memberof ADVFileControl
     */
    'entryAddendaCount': number;
    /**
     * Calculated in the same manner as the batch total but includes total from entire file
     * @type {number}
     * @memberof ADVFileControl
     */
    'entryHash': number;
    /**
     * Accumulated Batch debit totals within the file.
     * @type {number}
     * @memberof ADVFileControl
     */
    'totalDebit': number;
    /**
     * Accumulated Batch credit totals within the file.
     * @type {number}
     * @memberof ADVFileControl
     */
    'totalCredit': number;
}
/**
 * 
 * @export
 * @interface Addenda02
 */
export interface Addenda02 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda02
     */
    'id'?: string;
    /**
     * 02 - NACHA regulations
     * @type {string}
     * @memberof Addenda02
     */
    'typeCode': string;
    /**
     * ReferenceInformationOne may be used for additional reference numbers, identification numbers, or codes that the merchant needs to identify the particular transaction or customer. 
     * @type {string}
     * @memberof Addenda02
     */
    'referenceInformationOne'?: string;
    /**
     * ReferenceInformationTwo may be used for additional reference numbers, identification numbers, or codes that the merchant needs to identify the particular transaction or customer. 
     * @type {string}
     * @memberof Addenda02
     */
    'referenceInformationTwo'?: string;
    /**
     * TerminalIdentificationCode identifies an Electronic terminal with a unique code that allows a terminal owner and/or switching network to identify the terminal at which an Entry originated. 
     * @type {string}
     * @memberof Addenda02
     */
    'terminalIdentificationCode': string;
    /**
     * TransactionSerialNumber is assigned by the terminal at the time the transaction is originated.  The number, with the Terminal Identification Code, serves as an audit trail for the transaction and is usually assigned in ascending sequence. 
     * @type {string}
     * @memberof Addenda02
     */
    'transactionSerialNumber': string;
    /**
     * Timestamp identifies the date on which the transaction occurred. (Format MMDD - M=Month, D=Day)
     * @type {string}
     * @memberof Addenda02
     */
    'transactionDate': string;
    /**
     * Indicates the code that a card authorization center has furnished to the merchant.
     * @type {string}
     * @memberof Addenda02
     */
    'authorizationCodeOrExpireDate'?: string;
    /**
     * Identifies the specific location of a terminal (i.e., street names of an intersection, address, etc.) in accordance with the requirements of Regulation E.
     * @type {string}
     * @memberof Addenda02
     */
    'terminalLocation': string;
    /**
     * Identifies the city in which the electronic terminal is located.
     * @type {string}
     * @memberof Addenda02
     */
    'terminalCity': string;
    /**
     * Identifies the state in which the electronic terminal is located.
     * @type {string}
     * @memberof Addenda02
     */
    'terminalState': string;
    /**
     * Entry Detail Trace Number
     * @type {string}
     * @memberof Addenda02
     */
    'traceNumber'?: string;
}
/**
 * 
 * @export
 * @interface Addenda05
 */
export interface Addenda05 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda05
     */
    'id'?: string;
    /**
     * 05 - NACHA regulations
     * @type {string}
     * @memberof Addenda05
     */
    'typeCode': string;
    /**
     * Text for describing the related payment
     * @type {string}
     * @memberof Addenda05
     */
    'paymentRelatedInformation': string;
    /**
     * SequenceNumber is consecutively assigned to each Addenda05 Record following an Entry Detail Record. The first Addenda05 sequence number must always be a 1.
     * @type {number}
     * @memberof Addenda05
     */
    'sequenceNumber': number;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda05
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda10
 */
export interface Addenda10 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda10
     */
    'id'?: string;
    /**
     * 10 - NACHA regulations
     * @type {string}
     * @memberof Addenda10
     */
    'typeCode': string;
    /**
     * Describes the type of payment: \'ANN\' = Annuity | \'BUS\' = Business/Commercial | \'DEP\' = Deposit | \'LOA\' = Loan | \'MIS\' = Miscellaneous | \'MOR\' = Mortgage | \'PEN\' = Pension | \'RLS\' = Rent/Lease | \'REM\' = Remittance2 | \'SAL\' = Salary/Payroll | \'TAX\' = Tax | \'TEL\' = Telephone-Initiated Transaction | \'WEB\' = Internet-Initiated Transaction | \'ARC\' = Accounts Receivable Entry | \'BOC\' = Back Office Conversion Entry | \'POP\' = Point of Purchase Entry | \'RCK\' = Re-presented Check Entry 
     * @type {string}
     * @memberof Addenda10
     */
    'transactionTypeCode'?: string;
    /**
     * For inbound IAT payments this field should contain the USD amount or may be blank.
     * @type {number}
     * @memberof Addenda10
     */
    'foreignPaymentAmount': number;
    /**
     * Trace number
     * @type {string}
     * @memberof Addenda10
     */
    'foreignTraceNumber'?: string;
    /**
     * Receiving Company Name/Individual Name
     * @type {string}
     * @memberof Addenda10
     */
    'name': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda10
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda11
 */
export interface Addenda11 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda11
     */
    'id'?: string;
    /**
     * 11 - NACHA regulations
     * @type {string}
     * @memberof Addenda11
     */
    'typeCode': string;
    /**
     * Originator\'s name (your company name / name)
     * @type {string}
     * @memberof Addenda11
     */
    'originatorName': string;
    /**
     * Originator\'s street address
     * @type {string}
     * @memberof Addenda11
     */
    'originatorStreetAddress': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda11
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda12
 */
export interface Addenda12 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda12
     */
    'id'?: string;
    /**
     * 12 - NACHA regulations
     * @type {string}
     * @memberof Addenda12
     */
    'typeCode': string;
    /**
     * Originator City & State / Province Data elements City and State / Province  should be separated with an asterisk (*) as a delimiter and the field should end with a backslash (\\\\). 
     * @type {string}
     * @memberof Addenda12
     */
    'originatorCityStateProvince': string;
    /**
     * Originator Country & Postal Code Data elements must be separated by an asterisk (*) and must end with a backslash (\\\\). 
     * @type {string}
     * @memberof Addenda12
     */
    'originatorCountryPostalCode': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda12
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda13
 */
export interface Addenda13 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda13
     */
    'id'?: string;
    /**
     * 13 - NACHA regulations
     * @type {string}
     * @memberof Addenda13
     */
    'typeCode': string;
    /**
     * Originating DFI Name For Outbound IAT Entries, this field must contain the name of the U.S. ODFI. For Inbound IATs: Name of the foreign bank providing funding for the payment transaction 
     * @type {string}
     * @memberof Addenda13
     */
    'ODFIName': string;
    /**
     * Originating DFI Identification Number Qualifier. For Inbound IATs: The 2-digit code that identifies the numbering scheme used in the Foreign DFI Identification Number field: \'01\' = National Clearing System | \'02\' = BIC Code | \'03\' = IBAN Code 
     * @type {string}
     * @memberof Addenda13
     */
    'ODFIIDNumberQualifier': string;
    /**
     * Originating DFI Identification. This field contains the routing number that identifies the U.S. ODFI initiating the entry. For Inbound IATs: This field contains the bank ID number of the Foreign Bank providing funding for the payment transaction. 
     * @type {string}
     * @memberof Addenda13
     */
    'ODFIIdentification'?: string;
    /**
     * Originating DFI Branch Country Code: USb = United States //(\"b\" indicates a blank space) For Inbound IATs: This 3 position field contains a 2-character code as approved by the International Organization for Standardization (ISO) used to identify the country in which the branch of the bank that originated the entry is located. Values for other countries can be found on the International Organization for Standardization website: www.iso.org. 
     * @type {string}
     * @memberof Addenda13
     */
    'ODFIBranchCountryCode': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda13
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda14
 */
export interface Addenda14 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda14
     */
    'id'?: string;
    /**
     * 14 - NACHA regulations
     * @type {string}
     * @memberof Addenda14
     */
    'typeCode': string;
    /**
     * Name of the Receiver bank
     * @type {string}
     * @memberof Addenda14
     */
    'RDFIName': string;
    /**
     * Receiving DFI Identification Number Qualifier. The 2-digit code that identifies the numbering scheme used in the Receiving DFI Identification Number field: \'01\' = National Clearing System | \'02\' = BIC Code | \'03\' = IBAN Code 
     * @type {string}
     * @memberof Addenda14
     */
    'RDFIIDNumberQualifier': string;
    /**
     * This field contains the bank identification number of the DFI at which the Receiver maintains his account.
     * @type {string}
     * @memberof Addenda14
     */
    'RDFIIdentification': string;
    /**
     * Receiving DFI Branch Country Code USb\" = United States (\"b\" indicates a blank space) This 3 position field contains a 2-character code as approved by the International Organization for Standardization (ISO) used to identify the country in which the branch of the bank that receives the entry is located. Values for other countries can be found on the International Organization for Standardization website: www.iso.org 
     * @type {string}
     * @memberof Addenda14
     */
    'RDFIBranchCountryCode': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda14
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda15
 */
export interface Addenda15 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda15
     */
    'id'?: string;
    /**
     * 15 - NACHA regulations
     * @type {string}
     * @memberof Addenda15
     */
    'typeCode': string;
    /**
     * Receiver Identification Number contains the accounting number by which the Originator is known to the Receiver for descriptive purposes. NACHA Rules recommend but do not require the RDFI to print the contents of this field on the receiver\'s statement. 
     * @type {string}
     * @memberof Addenda15
     */
    'receiverIDNumber'?: string;
    /**
     * Receiver\'s physical address
     * @type {string}
     * @memberof Addenda15
     */
    'receiverStreetAddress': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda15
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda16
 */
export interface Addenda16 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda16
     */
    'id'?: string;
    /**
     * 16 - NACHA regulations
     * @type {string}
     * @memberof Addenda16
     */
    'typeCode': string;
    /**
     * Receiver City & State / Province Data elements City and State / Province  should be separated with an asterisk (*) as a delimiter and the field should end with a backslash (\\\\). 
     * @type {string}
     * @memberof Addenda16
     */
    'receiverCityStateProvince': string;
    /**
     * Receiver Country & Postal Code Data elements must be separated by an asterisk (*) and must end with a backslash (\\\\). 
     * @type {string}
     * @memberof Addenda16
     */
    'receiverCountryPostalCode': string;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda16
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda17
 */
export interface Addenda17 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda17
     */
    'id'?: string;
    /**
     * 17 - NACHA regulations
     * @type {string}
     * @memberof Addenda17
     */
    'typeCode': string;
    /**
     * Additional information related to the payment
     * @type {string}
     * @memberof Addenda17
     */
    'paymentRelatedInformation': string;
    /**
     * SequenceNumber is consecutively assigned to each Addenda17 Record following an Entry Detail Record. The first Addenda17 sequence number must always be a 1. 
     * @type {number}
     * @memberof Addenda17
     */
    'sequenceNumber': number;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda17
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda18
 */
export interface Addenda18 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda18
     */
    'id'?: string;
    /**
     * 18 - NACHA regulations
     * @type {string}
     * @memberof Addenda18
     */
    'typeCode': string;
    /**
     * Name of the Foreign Correspondent Bank
     * @type {string}
     * @memberof Addenda18
     */
    'foreignCorrespondentBankName': string;
    /**
     * Foreign Correspondent Bank Identification Number Qualifier contains a 2-digit code that identifies the numbering scheme used in the Foreign Correspondent Bank Identification Number field. Code values for this field are:   \"01\" = National Clearing System |   \"02\" = BIC Code |   \"03\" = IBAN Code 
     * @type {string}
     * @memberof Addenda18
     */
    'foreignCorrespondentBankIDNumberQualifier'?: string;
    /**
     * Foreign Correspondent Bank Identification Number contains the bank ID number of the Foreign Correspondent Bank
     * @type {string}
     * @memberof Addenda18
     */
    'foreignCorrespondentBankIDNumber': string;
    /**
     * Foreign Correspondent Bank Branch Country Code contains the two-character code, as approved by the International Organization for Standardization (ISO), to identify the country in which the branch of the Foreign Correspondent Bank is located. Values can be found on the International Organization for Standardization website: www.iso.org 
     * @type {string}
     * @memberof Addenda18
     */
    'foreignCorrespondentBankBranchCountryCode': string;
    /**
     * SequenceNumber is consecutively assigned to each Addenda17 Record following an Entry Detail Record. The first Addenda17 sequence number must always be a 1. 
     * @type {number}
     * @memberof Addenda18
     */
    'sequenceNumber': number;
    /**
     * EntryDetailSequenceNumber contains the ascending sequence number section of the Entry Detail or Corporate Entry Detail Record\'s trace number. This number is the same as the last seven digits of the trace number of the related Entry Detail Record or Corporate Entry Detail Record. 
     * @type {number}
     * @memberof Addenda18
     */
    'entryDetailSequenceNumber': number;
}
/**
 * 
 * @export
 * @interface Addenda98
 */
export interface Addenda98 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda98
     */
    'id'?: string;
    /**
     * 98 - NACHA regulations
     * @type {string}
     * @memberof Addenda98
     */
    'typeCode': string;
    /**
     * ChangeCode field contains a standard code used by an ACH Operator or RDFI to describe the reason for a change Entry.
     * @type {string}
     * @memberof Addenda98
     */
    'changeCode': string;
    /**
     * OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification. The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI, in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization. 
     * @type {string}
     * @memberof Addenda98
     */
    'originalTrace': string;
    /**
     * The Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
     * @type {string}
     * @memberof Addenda98
     */
    'originalDFI': string;
    /**
     * Correct field value of what changeCode references
     * @type {string}
     * @memberof Addenda98
     */
    'correctedData': string;
    /**
     * Entry Detail Trace Number
     * @type {string}
     * @memberof Addenda98
     */
    'traceNumber'?: string;
}
/**
 * 
 * @export
 * @interface Addenda99
 */
export interface Addenda99 {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda99
     */
    'id'?: string;
    /**
     * 99 - NACHA regulations
     * @type {string}
     * @memberof Addenda99
     */
    'typeCode': string;
    /**
     * Standard code used by an ACH Operator or RDFI to describe the reason for returning an Entry.
     * @type {string}
     * @memberof Addenda99
     */
    'returnCode': string;
    /**
     * OriginalTrace This field contains the Trace Number as originally included on the forward Entry or Prenotification. The RDFI must include the Original Entry Trace Number in the Addenda Record of an Entry being returned to an ODFI, in the Addenda Record of an 98, within an Acknowledgment Entry, or with an RDFI request for a copy of an authorization. 
     * @type {string}
     * @memberof Addenda99
     */
    'originalTrace': string;
    /**
     * The field date of death is to be supplied on Entries being returned for reason of death (return reason codes R14 and R15). (Format YYMMDD - Y=Year, M=Month, D=Day)
     * @type {string}
     * @memberof Addenda99
     */
    'dateOfDeath': string;
    /**
     * Contains the Receiving DFI Identification (addenda.RDFIIdentification) as originally included on the forward Entry or Prenotification that the RDFI is returning or correcting.
     * @type {string}
     * @memberof Addenda99
     */
    'originalDFI': string;
    /**
     * Information related to the return
     * @type {string}
     * @memberof Addenda99
     */
    'addendaInformation'?: string;
    /**
     * Matches the Entry Detail Trace Number of the entry being returned.
     * @type {string}
     * @memberof Addenda99
     */
    'traceNumber'?: string;
}
/**
 * 
 * @export
 * @interface Addenda99Contested
 */
export interface Addenda99Contested {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda99Contested
     */
    'id'?: string;
    /**
     * 99 - NACHA regulations
     * @type {string}
     * @memberof Addenda99Contested
     */
    'typeCode': string;
    /**
     * return code explaining the contested dishonorment
     * @type {string}
     * @memberof Addenda99Contested
     */
    'contestedReturnCode': string;
    /**
     * Date original entry was returned
     * @type {string}
     * @memberof Addenda99Contested
     */
    'dateOriginalEntryReturned': string;
    /**
     * Return reason code of the Dishonored Return
     * @type {string}
     * @memberof Addenda99Contested
     */
    'dishonoredReturnReasonCode': string;
    /**
     * Trace number from Dishonored Return
     * @type {string}
     * @memberof Addenda99Contested
     */
    'dishonoredReturnTraceNumber': string;
    /**
     * Settlement date of the Dishonored Return
     * @type {string}
     * @memberof Addenda99Contested
     */
    'dishonoredReturnSettlementDate': string;
    /**
     * Trace Number of the original entry being returned.
     * @type {string}
     * @memberof Addenda99Contested
     */
    'originalEntryTraceNumber': string;
    /**
     * Identification of the Original Receiving Depository Institution (ODFI)
     * @type {string}
     * @memberof Addenda99Contested
     */
    'originalReceivingDFIIdentification': string;
    /**
     * Original date of settlement
     * @type {string}
     * @memberof Addenda99Contested
     */
    'originalSettlementDate': string;
    /**
     * Return trace number
     * @type {string}
     * @memberof Addenda99Contested
     */
    'returnTraceNumber': string;
    /**
     * Return settlement date
     * @type {string}
     * @memberof Addenda99Contested
     */
    'returnSettlementDate': string;
    /**
     * Return reason code
     * @type {string}
     * @memberof Addenda99Contested
     */
    'returnReasonCode': string;
    /**
     * Unique Trace Number for the contested dishonored return
     * @type {string}
     * @memberof Addenda99Contested
     */
    'traceNumber': string;
}
/**
 * 
 * @export
 * @interface Addenda99Dishonored
 */
export interface Addenda99Dishonored {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'id'?: string;
    /**
     * 99 - NACHA regulations
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'typeCode': string;
    /**
     * Trace Number of the original entry being returned.
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'originalEntryTraceNumber': string;
    /**
     * Identification of the Original Receiving Depository Institution (ODFI)
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'originalReceivingDFIIdentification': string;
    /**
     * Return trace number
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'returnTraceNumber': string;
    /**
     * Return settlement date
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'returnSettlementDate': string;
    /**
     * Return reason code
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'returnReasonCode': string;
    /**
     * Return reason code of the Dishonored Return
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'dishonoredReturnReasonCode': string;
    /**
     * Matches the Entry Detail Trace Number of the entry being returned.
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'traceNumber'?: string;
    /**
     * Additional data
     * @type {string}
     * @memberof Addenda99Dishonored
     */
    'addendaInformation'?: string;
}
/**
 * 
 * @export
 * @interface Batch
 */
export interface Batch {
    /**
     * 
     * @type {BatchHeader}
     * @memberof Batch
     */
    'batchHeader': BatchHeader;
    /**
     * 
     * @type {Array<EntryDetail>}
     * @memberof Batch
     */
    'entryDetails': Array<EntryDetail>;
    /**
     * 
     * @type {BatchControl}
     * @memberof Batch
     */
    'batchControl': BatchControl;
    /**
     * 
     * @type {Array<ADVEntryDetail>}
     * @memberof Batch
     */
    'advEntryDetails'?: Array<ADVEntryDetail>;
    /**
     * 
     * @type {ADVBatchControl}
     * @memberof Batch
     */
    'advBatchControl'?: ADVBatchControl;
}
/**
 * 
 * @export
 * @interface BatchControl
 */
export interface BatchControl {
    /**
     * Batch ID
     * @type {string}
     * @memberof BatchControl
     */
    'id'?: string;
    /**
     * Same as ServiceClassCode in BatchHeaderRecord
     * @type {number}
     * @memberof BatchControl
     */
    'serviceClassCode': number;
    /**
     * EntryAddendaCount is a tally of each Entry Detail Record and each Addenda Record processed, within either the batch or file as appropriate.
     * @type {number}
     * @memberof BatchControl
     */
    'entryAddendaCount': number;
    /**
     * Validate the Receiving DFI Identification in each Entry Detail Record is hashed to provide a check against inadvertent alteration of data contents due to hardware failure or program error. In this context the Entry Hash is the sum of the corresponding fields in the Entry Detail Records on the file. 
     * @type {number}
     * @memberof BatchControl
     */
    'entryHash': number;
    /**
     * Contains accumulated Entry debit totals within the batch.
     * @type {number}
     * @memberof BatchControl
     */
    'totalDebit': number;
    /**
     * Contains accumulated Entry credit totals within the batch.
     * @type {number}
     * @memberof BatchControl
     */
    'totalCredit': number;
    /**
     * Alphanumeric code used to identify an Originator. The Company Identification Field must be included on all prenotification records and on each entry initiated pursuant to such prenotification. The Company ID may begin with the ANSI one-digit Identification Code Designator (ICD), followed by the identification number. Possible ICDs are the IRS Employer Identification Number (EIN) \"1\", Data Universal Numbering Systems (DUNS) \"3\", and User Assigned Number \"9\". 
     * @type {string}
     * @memberof BatchControl
     */
    'companyIdentification': string;
    /**
     * MAC is an eight character code derived from a special key used in conjunction with the DES algorithm. The purpose of the MAC is to validate the authenticity of ACH entries. The DES algorithm and key message standards must be in accordance with standards adopted by the American National Standards Institute. The remaining eleven characters of this field are blank.
     * @type {string}
     * @memberof BatchControl
     */
    'messageAuthentication'?: string;
    /**
     * The routing number is used to identify the DFI originating entries within a given branch.
     * @type {string}
     * @memberof BatchControl
     */
    'ODFIIdentification': string;
    /**
     * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record.
     * @type {number}
     * @memberof BatchControl
     */
    'batchNumber': number;
}
/**
 * 
 * @export
 * @interface BatchHeader
 */
export interface BatchHeader {
    /**
     * A client-defined ID used as a reference to this batch
     * @type {string}
     * @memberof BatchHeader
     */
    'id'?: string;
    /**
     * Service Class Code - Mixed Debits and Credits \'200\', ACH Credits Only \'220\', or ACH Debits Only \'225\'
     * @type {number}
     * @memberof BatchHeader
     */
    'serviceClassCode': number;
    /**
     * Company originating the entries in the batch
     * @type {string}
     * @memberof BatchHeader
     */
    'companyName': string;
    /**
     * The 9 digit FEIN number (proceeded by a predetermined alpha or numeric character) of the entity in the company name field
     * @type {string}
     * @memberof BatchHeader
     */
    'companyDiscretionaryData'?: string;
    /**
     * Alphanumeric code used to identify an Originator. The Company Identification Field must be included on all prenotification records and on each entry initiated pursuant to such prenotification. The Company ID may begin with the ANSI one-digit Identification Code Designator (ICD), followed by the identification number. Possible ICDs are the IRS Employer Identification Number (EIN) \"1\", Data Universal Numbering Systems (DUNS) \"3\", or User Assigned Number \"9\". 
     * @type {string}
     * @memberof BatchHeader
     */
    'companyIdentification': string;
    /**
     * Identifies the payment type (product) found within an ACH batch using a 3-character code.
     * @type {string}
     * @memberof BatchHeader
     */
    'standardEntryClassCode': string;
    /**
     * A description of the entries contained in the batch. The Originator establishes the value of this field to provide a description of the purpose of the entry to be displayed back to the receiver. For example, \"GAS BILL,\" \"REG. SALARY,\" \"INS. PREM,\", \"SOC. SEC.,\" \"DTC,\" \"TRADE PAY,\" \"PURCHASE,\" etc. This field must contain the word \"REVERSAL\" (left justified) when the batch contains reversing entries. This field must contain the word \"RECLAIM\" (left justified) when the batch contains reclamation entries. This field must contain the word \"NONSETTLED\" (left justified) when the batch contains entries which could not settle. 
     * @type {string}
     * @memberof BatchHeader
     */
    'companyEntryDescription'?: string;
    /**
     * The Originator establishes this field as the date it would like to see displayed to the receiver for descriptive purposes. This field is never used to control timing of any computer or manual operation. It is solely for descriptive purposes. The RDFI should not assume any specific format. 
     * @type {string}
     * @memberof BatchHeader
     */
    'companyDescriptiveDate'?: string;
    /**
     * Date on which the entries are to settle. (Format YYMMDD - Y=Year, M=Month, D=Day)
     * @type {string}
     * @memberof BatchHeader
     */
    'effectiveEntryDate'?: string;
    /**
     * ODFI initiating the Entry. | 0 - ADV File prepared by an ACH Operator. | 1 - This code identifies the Originator as a depository financial institution. | 2 - This code identifies the Originator as a Federal Government entity or agency. 
     * @type {number}
     * @memberof BatchHeader
     */
    'originatorStatusCode'?: number;
    /**
     * First 8 digits of the originating DFI transit routing number
     * @type {string}
     * @memberof BatchHeader
     */
    'ODFIIdentification': string;
    /**
     * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record. 
     * @type {number}
     * @memberof BatchHeader
     */
    'batchNumber': number;
    /**
     * The date the entries actually settled (this is inserted by the ACH operator)
     * @type {string}
     * @memberof BatchHeader
     */
    'settlementDate'?: string;
}
/**
 * 
 * @export
 * @interface CreateFile
 */
export interface CreateFile {
    /**
     * File ID
     * @type {string}
     * @memberof CreateFile
     */
    'id'?: string;
    /**
     * 
     * @type {FileHeader}
     * @memberof CreateFile
     */
    'fileHeader': FileHeader;
    /**
     * 
     * @type {Array<Batch>}
     * @memberof CreateFile
     */
    'batches'?: Array<Batch>;
    /**
     * 
     * @type {Array<IATBatch>}
     * @memberof CreateFile
     */
    'IATBatches'?: Array<IATBatch>;
    /**
     * 
     * @type {FileControl}
     * @memberof CreateFile
     */
    'fileControl'?: FileControl;
    /**
     * 
     * @type {Array<ADVEntryDetail>}
     * @memberof CreateFile
     */
    'advEntryDetails'?: Array<ADVEntryDetail>;
    /**
     * 
     * @type {ADVBatchControl}
     * @memberof CreateFile
     */
    'advBatchControl'?: ADVBatchControl;
}
/**
 * 
 * @export
 * @interface CreateFileResponse
 */
export interface CreateFileResponse {
    /**
     * File ID
     * @type {string}
     * @memberof CreateFileResponse
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof CreateFileResponse
     */
    'file'?: any;
    /**
     * An error message describing the problem intended for humans.
     * @type {string}
     * @memberof CreateFileResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface EntryDetail
 */
export interface EntryDetail {
    /**
     * Entry Detail ID
     * @type {string}
     * @memberof EntryDetail
     */
    'id': string;
    /**
     * Based on transaction type: 22 - Credit (deposit) to checking account | 23 - Prenote for credit to checking account | 27 - Debit (withdrawal) to checking account | 28 - Prenote for debit to checking account | 32 - Credit to savings account | 33 - Prenote for credit to savings account | 37 - Debit to savings account | 38 - Prenote for debit to savings account 
     * @type {number}
     * @memberof EntryDetail
     */
    'transactionCode': number;
    /**
     * RDFI\'s routing number without the last digit.
     * @type {string}
     * @memberof EntryDetail
     */
    'RDFIIdentification': string;
    /**
     * Last digit in RDFI routing number.
     * @type {string}
     * @memberof EntryDetail
     */
    'checkDigit': string;
    /**
     * The receiver\'s bank account number you are crediting/debiting. It important to note that this is an alphanumeric field, so it\'s space padded, not zero padded 
     * @type {string}
     * @memberof EntryDetail
     */
    'DFIAccountNumber': string;
    /**
     * Number of cents you are debiting/crediting this account
     * @type {number}
     * @memberof EntryDetail
     */
    'amount': number;
    /**
     * Internal identification (alphanumeric) that you use to uniquely identify this Entry Detail Record
     * @type {string}
     * @memberof EntryDetail
     */
    'identificationNumber'?: string;
    /**
     * The name of the receiver, usually the name on the bank account
     * @type {string}
     * @memberof EntryDetail
     */
    'individualName': string;
    /**
     * DiscretionaryData allows ODFIs to include codes, of significance only to them, to enable specialized handling of the entry. There will be no standardized interpretation for the value of this field. It can either be a single two-character code, or two distinct one-character codes, according to the needs of the ODFI and/or Originator involved. This field must be returned intact for any returned entry. WEB uses the Discretionary Data Field as the Payment Type Code. 
     * @type {string}
     * @memberof EntryDetail
     */
    'discretionaryData'?: string;
    /**
     * AddendaRecordIndicator indicates the existence of an Addenda Record. A value of \"1\" indicates that one or more addenda records follow, and \"0\" means no such record is present. 
     * @type {number}
     * @memberof EntryDetail
     */
    'addendaRecordIndicator'?: number;
    /**
     * TraceNumber assigned by the ODFI in ascending sequence, is included in each Entry Detail Record, Corporate Entry Detail Record, and Addenda Record. Trace Numbers uniquely identify each entry within a batch in an ACH input file. In association with the Batch Number, transmission (File Creation) Date, and File ID Modifier, the Trace Number uniquely identifies an entry within a given file. For Addenda Records, the Trace Number will be identical to the Trace Number in the associated Entry Detail Record, since the Trace Number is associated with an entry or item rather than a physical record. 
     * @type {string}
     * @memberof EntryDetail
     */
    'traceNumber'?: string;
    /**
     * 
     * @type {Addenda02}
     * @memberof EntryDetail
     */
    'addenda02'?: Addenda02;
    /**
     * List of Addenda05 records
     * @type {Array<Addenda05>}
     * @memberof EntryDetail
     */
    'addenda05'?: Array<Addenda05>;
    /**
     * 
     * @type {Addenda98}
     * @memberof EntryDetail
     */
    'addenda98'?: Addenda98;
    /**
     * 
     * @type {Addenda99}
     * @memberof EntryDetail
     */
    'addenda99'?: Addenda99;
    /**
     * 
     * @type {Addenda99Dishonored}
     * @memberof EntryDetail
     */
    'addenda99Dishonored'?: Addenda99Dishonored;
    /**
     * 
     * @type {Addenda99Contested}
     * @memberof EntryDetail
     */
    'addenda99Contested'?: Addenda99Contested;
    /**
     * Category defines if the entry is a Forward, Return, or NOC
     * @type {string}
     * @memberof EntryDetail
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface FileControl
 */
export interface FileControl {
    /**
     * File ID
     * @type {string}
     * @memberof FileControl
     */
    'id'?: string;
    /**
     * Count of Batches in the File
     * @type {number}
     * @memberof FileControl
     */
    'batchCount': number;
    /**
     * Total number of records in the file (include all headers and trailer) divided by 10 (This number must be evenly divisible by 10. If not, additional records consisting of all 9\'s are added to the file after the initial \'9\' record to fill out the block 10.) 
     * @type {number}
     * @memberof FileControl
     */
    'blockCount': number;
    /**
     * Total detail and addenda records in the file
     * @type {number}
     * @memberof FileControl
     */
    'entryAddendaCount': number;
    /**
     * Calculated in the same manner as the batch total but includes total from entire file
     * @type {number}
     * @memberof FileControl
     */
    'entryHash': number;
    /**
     * Accumulated Batch debit totals within the file.
     * @type {number}
     * @memberof FileControl
     */
    'totalDebit': number;
    /**
     * Accumulated Batch credit totals within the file.
     * @type {number}
     * @memberof FileControl
     */
    'totalCredit': number;
}
/**
 * 
 * @export
 * @interface FileHeader
 */
export interface FileHeader {
    /**
     * File ID
     * @type {string}
     * @memberof FileHeader
     */
    'id'?: string;
    /**
     * Contains the Routing Number of the ACH Operator or sending point that is sending the file.
     * @type {string}
     * @memberof FileHeader
     */
    'immediateOrigin': string;
    /**
     * The name of the ACH Operator or sending point that is sending the file.
     * @type {string}
     * @memberof FileHeader
     */
    'immediateOriginName': string;
    /**
     * Contains the Routing Number of the ACH Operator or receiving point to which the file is being sent.
     * @type {string}
     * @memberof FileHeader
     */
    'immediateDestination': string;
    /**
     * The name of the ACH Operator or receiving point to which the file is being sent.
     * @type {string}
     * @memberof FileHeader
     */
    'immediateDestinationName': string;
    /**
     * The File Creation Time is the time when the file was prepared by an ODFI. (Format HHmm - H=Hour, m=Minute)
     * @type {string}
     * @memberof FileHeader
     */
    'fileCreationTime': string;
    /**
     * The File Creation Date is the date when the file was prepared by an ODFI. (Format YYMMDD - Y=Year, M=Month, D=Day)
     * @type {string}
     * @memberof FileHeader
     */
    'fileCreationDate': string;
    /**
     * Incremented value for each file for RDFIs.
     * @type {string}
     * @memberof FileHeader
     */
    'fileIDModifier'?: string;
    /**
     * Reserved field for information pertinent to the Originator.
     * @type {string}
     * @memberof FileHeader
     */
    'referenceCode'?: string;
}
/**
 * 
 * @export
 * @interface FlattenFileResponse
 */
export interface FlattenFileResponse {
    /**
     * File ID
     * @type {string}
     * @memberof FlattenFileResponse
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof FlattenFileResponse
     */
    'file'?: any;
    /**
     * An error message describing the problem intended for humans.
     * @type {string}
     * @memberof FlattenFileResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface IATBatch
 */
export interface IATBatch {
    /**
     * Client-defined string used as a reference to this record.
     * @type {string}
     * @memberof IATBatch
     */
    'id'?: string;
    /**
     * 
     * @type {IATBatchHeader}
     * @memberof IATBatch
     */
    'IATBatchHeader': IATBatchHeader;
    /**
     * 
     * @type {Array<IATEntryDetail>}
     * @memberof IATBatch
     */
    'IATEntryDetails': Array<IATEntryDetail>;
    /**
     * 
     * @type {BatchControl}
     * @memberof IATBatch
     */
    'batchControl': BatchControl;
}
/**
 * 
 * @export
 * @interface IATBatchHeader
 */
export interface IATBatchHeader {
    /**
     * ID is a client-defined string used as a reference to this record.
     * @type {string}
     * @memberof IATBatchHeader
     */
    'id'?: string;
    /**
     * Service Class Code - Mixed Debits and Credits \'200\', ACH Credits Only \'220\', or ACH Debits Only \'225\'
     * @type {number}
     * @memberof IATBatchHeader
     */
    'serviceClassCode': number;
    /**
     * Leave Blank. Only used for corrected IAT entries
     * @type {string}
     * @memberof IATBatchHeader
     */
    'IATIndicator'?: string;
    /**
     * Code indicating currency conversion: \'FV\' (Fixed-to-Variable)  Entry is originated in a fixed-value amount and is to be received in a variable amount resulting from the execution of the foreign exchange conversion. | \'VF\' (Variable-to-Fixed)  Entry is originated in a variable-value amount based on a specific foreign exchange rate for conversion to a fixed-value amount in which the entry is to be received. | \'FF\' (Fixed-to-Fixed)  Entry is originated in a fixed-value amount and is to be received in the same fixed-value amount in the same currency denomination. There is no foreign exchange conversion for entries transmitted using this code. For entries originated in a fixed value amount, the foreign Exchange Reference Field will be space filled. 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'foreignExchangeIndicator': string;
    /**
     * Code used to indicate the content of the Foreign Exchange Reference Field and is filled by the gateway operator. Valid entries are 1 - Foreign Exchange Rate | 2 - Foreign Exchange Reference Number | 3 - Space Filled 
     * @type {number}
     * @memberof IATBatchHeader
     */
    'foreignExchangeReferenceIndicator': number;
    /**
     * Contains either the foreign exchange rate used to execute the foreign exchange conversion of a cross-border entry or another reference to the foreign exchange transaction.
     * @type {string}
     * @memberof IATBatchHeader
     */
    'foreignExchangeReference': string;
    /**
     * Two-character code, as approved by the International Organization for Standardization (ISO), to identify the country in which the entry is to be received. For United States use US.
     * @type {string}
     * @memberof IATBatchHeader
     */
    'ISODestinationCountryCode': string;
    /**
     * For U.S. entities: the number assigned will be your tax ID (often Social Security Number) For non-U.S. entities: the number assigned will be your DDA number, or the last 9 characters of your account number if it exceeds 9 characters 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'originatorIdentification': string;
    /**
     * StandardEntryClassCode for consumer and non consumer international payments is IAT. Identifies the payment type (product) found within an ACH batch using a 3-character code. The SEC Code pertains to all items within batch. Determines format of the detail records. Determines addenda records (required or optional PLUS one or up to 9,999 records). Determines rules to follow (return time frames). Some SEC codes require specific data in predetermined fields within the ACH record. 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'standardEntryClassCode': string;
    /**
     * A description of the entries contained in the batch The Originator establishes the value of this field to provide a description of the purpose of the entry to be displayed back to the receiver. For example, \"GAS BILL,\" \"REG. SALARY,\" \"INS. PREM,\" \"SOC. SEC.,\" \"DTC,\" \"TRADE PAY,\" \"PURCHASE,\" etc. This field must contain the word \"REVERSAL\" (left justified) when the batch contains reversing entries. This field must contain the word \"RECLAIM\" (left justified) when the batch contains reclamation entries. This field must contain the word \"NONSETTLED\" (left justified) when the batch contains entries which could not settle. 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'companyEntryDescription'?: string;
    /**
     * Three-character code, as approved by the International Organization for Standardization (ISO), to identify the currency denomination in which the entry was first originated. If the source of funds is within the territorial jurisdiction of the U.S., enter \'USD\', otherwise refer to International Organization for Standardization website for value: www.iso.org 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'ISOOriginatingCurrencyCode': string;
    /**
     * ISODestinationCurrencyCode is the three-character code, as approved by the International Organization for Standardization (ISO), to identify the currency denomination in which the entry will ultimately be settled. If the final destination of funds is within the territorial jurisdiction of the U.S., enter \"USD\", otherwise refer to International Organization for Standardization website for value: www.iso.org 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'ISODestinationCurrencyCode': string;
    /**
     * EffectiveEntryDate the date on which the entries are to settle. Format YYMMDD (Y=Year, M=Month, D=Day) 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'effectiveEntryDate'?: string;
    /**
     * ODFI initiating the Entry. | 0 - ADV File prepared by an ACH Operator. | 1 - This code identifies the Originator as a depository financial institution. | 2 - This code identifies the Originator as a Federal Government entity or agency. 
     * @type {number}
     * @memberof IATBatchHeader
     */
    'originatorStatusCode'?: number;
    /**
     * First 8 digits of the originating DFI transit routing number. For Inbound IAT Entries, this field contains the routing number of the U.S. Gateway Operator.  For Outbound IAT Entries, this field contains the standard routing number, as assigned by Accuity, that identifies the U.S. ODFI initiating the Entry. (Format TTTTAAAA - T=Federal Reserve Routing Symbol, A=ABA Institution Identifier) 
     * @type {string}
     * @memberof IATBatchHeader
     */
    'ODFIIdentification': string;
    /**
     * BatchNumber is assigned in ascending sequence to each batch by the ODFI or its Sending Point in a given file of entries. Since the batch number in the Batch Header Record and the Batch Control Record is the same, the ascending sequence number should be assigned by batch and not by record. 
     * @type {number}
     * @memberof IATBatchHeader
     */
    'batchNumber': number;
    /**
     * The date the entries actually settled (this is inserted by the ACH operator)
     * @type {string}
     * @memberof IATBatchHeader
     */
    'settlementDate'?: string;
}
/**
 * 
 * @export
 * @interface IATEntryDetail
 */
export interface IATEntryDetail {
    /**
     * Entry Detail ID
     * @type {string}
     * @memberof IATEntryDetail
     */
    'id'?: string;
    /**
     * Based on transaction type: 22 - Credit (deposit) to checking account | 23 - Prenote for credit to checking account | 27 - Debit (withdrawal) to checking account | 28 - Prenote for debit to checking account | 32 - Credit to savings account | 33 - Prenote for credit to savings account | 37 - Debit to savings account | 38 - Prenote for debit to savings account 
     * @type {number}
     * @memberof IATEntryDetail
     */
    'transactionCode': number;
    /**
     * RDFI\'s routing number without the last digit.
     * @type {string}
     * @memberof IATEntryDetail
     */
    'RDFIIdentification': string;
    /**
     * Last digit in RDFI routing number.
     * @type {string}
     * @memberof IATEntryDetail
     */
    'checkDigit': string;
    /**
     * Number of Addenda Records
     * @type {number}
     * @memberof IATEntryDetail
     */
    'addendaRecords': number;
    /**
     * Number of cents you are debiting/crediting this account
     * @type {number}
     * @memberof IATEntryDetail
     */
    'amount': number;
    /**
     * The receiver\'s bank account number you are crediting/debiting. It important to note that this is an alphanumeric field, so it\'s space padded, not zero padded 
     * @type {string}
     * @memberof IATEntryDetail
     */
    'DFIAccountNumber': string;
    /**
     * Signifies if the record has been screened against OFAC records
     * @type {string}
     * @memberof IATEntryDetail
     */
    'OFACScreeningIndicator': string;
    /**
     * Signifies if the record has been screened against OFAC records by a secondary entry
     * @type {string}
     * @memberof IATEntryDetail
     */
    'secondaryOFACScreeningIndicator': string;
    /**
     * AddendaRecordIndicator indicates the existence of an Addenda Record. A value of \"1\" indicates that one or more addenda records follow, and \"0\" means no such record is present. 
     * @type {number}
     * @memberof IATEntryDetail
     */
    'addendaRecordIndicator': number;
    /**
     * Matches the Entry Detail Trace Number of the entry being returned.
     * @type {string}
     * @memberof IATEntryDetail
     */
    'traceNumber'?: string;
    /**
     * 
     * @type {Addenda10}
     * @memberof IATEntryDetail
     */
    'addenda10': Addenda10;
    /**
     * 
     * @type {Addenda11}
     * @memberof IATEntryDetail
     */
    'addenda11': Addenda11;
    /**
     * 
     * @type {Addenda12}
     * @memberof IATEntryDetail
     */
    'addenda12': Addenda12;
    /**
     * 
     * @type {Addenda13}
     * @memberof IATEntryDetail
     */
    'addenda13': Addenda13;
    /**
     * 
     * @type {Addenda14}
     * @memberof IATEntryDetail
     */
    'addenda14': Addenda14;
    /**
     * 
     * @type {Addenda15}
     * @memberof IATEntryDetail
     */
    'addenda15': Addenda15;
    /**
     * 
     * @type {Addenda16}
     * @memberof IATEntryDetail
     */
    'addenda16': Addenda16;
    /**
     * 
     * @type {Addenda17}
     * @memberof IATEntryDetail
     */
    'addenda17'?: Addenda17;
    /**
     * 
     * @type {Addenda18}
     * @memberof IATEntryDetail
     */
    'addenda18'?: Addenda18;
    /**
     * 
     * @type {Addenda98}
     * @memberof IATEntryDetail
     */
    'addenda98'?: Addenda98;
    /**
     * 
     * @type {Addenda99}
     * @memberof IATEntryDetail
     */
    'addenda99'?: Addenda99;
    /**
     * Category defines if the entry is a Forward, Return, or NOC
     * @type {string}
     * @memberof IATEntryDetail
     */
    'category'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * An error message describing the problem intended for humans.
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * File ID
     * @type {string}
     * @memberof ModelFile
     */
    'id'?: string;
    /**
     * 
     * @type {FileHeader}
     * @memberof ModelFile
     */
    'fileHeader': FileHeader;
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ModelFile
     */
    'batches'?: Array<Batch>;
    /**
     * 
     * @type {Array<IATBatch>}
     * @memberof ModelFile
     */
    'IATBatches'?: Array<IATBatch>;
    /**
     * 
     * @type {FileControl}
     * @memberof ModelFile
     */
    'fileControl': FileControl;
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ModelFile
     */
    'NotificationOfChange'?: Array<Batch> | null;
    /**
     * 
     * @type {Array<Batch>}
     * @memberof ModelFile
     */
    'ReturnEntries'?: Array<Batch> | null;
    /**
     * 
     * @type {ADVFileControl}
     * @memberof ModelFile
     */
    'fileADVControl'?: ADVFileControl;
}
/**
 * 
 * @export
 * @interface Offset
 */
export interface Offset {
    /**
     * ABA routing number
     * @type {string}
     * @memberof Offset
     */
    'routingNumber': string;
    /**
     * Account number used to offset records
     * @type {string}
     * @memberof Offset
     */
    'accountNumber': string;
    /**
     * Account type used in offset record
     * @type {string}
     * @memberof Offset
     */
    'accountType': OffsetAccountTypeEnum;
    /**
     * Memo for Offset EntryDetail record
     * @type {string}
     * @memberof Offset
     */
    'description': string;
}

export const OffsetAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings'
} as const;

export type OffsetAccountTypeEnum = typeof OffsetAccountTypeEnum[keyof typeof OffsetAccountTypeEnum];

/**
 * 
 * @export
 * @interface SegmentFile
 */
export interface SegmentFile {
    /**
     * 
     * @type {any}
     * @memberof SegmentFile
     */
    'file'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentFile
     */
    'opts'?: any;
}
/**
 * 
 * @export
 * @interface SegmentedFiles
 */
export interface SegmentedFiles {
    /**
     * File ID
     * @type {string}
     * @memberof SegmentedFiles
     */
    'creditFileID'?: string;
    /**
     * 
     * @type {any}
     * @memberof SegmentedFiles
     */
    'creditFile'?: any;
    /**
     * File ID
     * @type {string}
     * @memberof SegmentedFiles
     */
    'debitFileID'?: string;
    /**
     * 
     * @type {any}
     * @memberof SegmentedFiles
     */
    'debitFile'?: any;
    /**
     * An error message describing the problem intended for humans.
     * @type {string}
     * @memberof SegmentedFiles
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface ValidateOpts
 */
export interface ValidateOpts {
    /**
     * Require that the FileHeader ImmediateOrigin routing number which checksum matches.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'requireABAOrigin'?: boolean;
    /**
     * Skip ImmediateOrigin validation steps.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'bypassOriginValidation'?: boolean;
    /**
     * Skip ImmediateDestination validation steps.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'bypassDestinationValidation'?: boolean;
    /**
     * Disable Nacha specified checks of TraceNumbers.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'customTraceNumbers'?: boolean;
    /**
     * Allow the file to have zero batches.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'allowZeroBatches'?: boolean;
    /**
     * Allow the file to be read without a FileHeader record.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'allowMissingFileHeader'?: boolean;
    /**
     * Allow the file to be read without a FileControl record.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'allowMissingFileControl'?: boolean;
    /**
     * Allow batches in which the Company Identification field in the batch header and control do not match.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'bypassCompanyIdentificationMatch'?: boolean;
    /**
     * Allow for non-standard/deprecated return codes (e.g. R97)
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'customReturnCodes'?: boolean;
    /**
     * Skip equality checks for the ServiceClassCode in each pair of BatchHeader and BatchControl records.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'unequalServiceClassCode'?: boolean;
    /**
     * Allow a file to be read with unordered batch numbers.
     * @type {boolean}
     * @memberof ValidateOpts
     */
    'allowUnorderedBatchNumbers'?: boolean;
}

/**
 * ACHFilesApi - axios parameter creator
 * @export
 */
export const ACHFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Append a Batch record to the specified File.
         * @summary Append Batch to File
         * @param {string} fileID File ID
         * @param {Batch} batch 
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchToFile: async (fileID: string, batch: Batch, xRequestID?: string, xIdempotencyKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('addBatchToFile', 'fileID', fileID)
            // verify required parameter 'batch' is not null or undefined
            assertParamExists('addBatchToFile', 'batch', batch)
            const localVarPath = `/files/{fileID}/batches`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
         * @summary Build File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFile: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('buildFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/build`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFile: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('checkFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/validate`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new File object from either the plaintext or JSON representation.
         * @summary Create File
         * @param {string} fileID File ID
         * @param {string} body Content of the ACH file (in json or raw text)
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {boolean} [requireABAOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassDestination] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customTraceNumbers] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowZeroBatches] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileHeader] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileControl] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [bypassCompanyIdentificationMatch] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customReturnCodes] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [unequalServiceClassCode] Optional parameter to configure ImmediateDestination validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile: async (fileID: string, body: string, xRequestID?: string, xIdempotencyKey?: string, requireABAOrigin?: boolean, bypassOrigin?: boolean, bypassDestination?: boolean, customTraceNumbers?: boolean, allowZeroBatches?: boolean, allowMissingFileHeader?: boolean, allowMissingFileControl?: boolean, bypassCompanyIdentificationMatch?: boolean, customReturnCodes?: boolean, unequalServiceClassCode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('createFile', 'fileID', fileID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createFile', 'body', body)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requireABAOrigin !== undefined) {
                localVarQueryParameter['requireABAOrigin'] = requireABAOrigin;
            }

            if (bypassOrigin !== undefined) {
                localVarQueryParameter['bypassOrigin'] = bypassOrigin;
            }

            if (bypassDestination !== undefined) {
                localVarQueryParameter['bypassDestination'] = bypassDestination;
            }

            if (customTraceNumbers !== undefined) {
                localVarQueryParameter['customTraceNumbers'] = customTraceNumbers;
            }

            if (allowZeroBatches !== undefined) {
                localVarQueryParameter['allowZeroBatches'] = allowZeroBatches;
            }

            if (allowMissingFileHeader !== undefined) {
                localVarQueryParameter['allowMissingFileHeader'] = allowMissingFileHeader;
            }

            if (allowMissingFileControl !== undefined) {
                localVarQueryParameter['allowMissingFileControl'] = allowMissingFileControl;
            }

            if (bypassCompanyIdentificationMatch !== undefined) {
                localVarQueryParameter['bypassCompanyIdentificationMatch'] = bypassCompanyIdentificationMatch;
            }

            if (customReturnCodes !== undefined) {
                localVarQueryParameter['customReturnCodes'] = customReturnCodes;
            }

            if (unequalServiceClassCode !== undefined) {
                localVarQueryParameter['unequalServiceClassCode'] = unequalServiceClassCode;
            }

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a File and associated Batches. It cannot be undone.
         * @summary Delete File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACHFile: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('deleteACHFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Batch from a File.
         * @summary Delete Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileBatch: async (fileID: string, batchID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('deleteFileBatch', 'fileID', fileID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('deleteFileBatch', 'batchID', batchID)
            const localVarPath = `/files/{fileID}/batches/{batchID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consolidate Batches and Entries into the minimum number of Batches needed.
         * @summary Flatten Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flattenFile: async (fileID: string, xRequestID?: string, xIdempotencyKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('flattenFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/flatten`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific Batch on a File.
         * @summary Get Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileBatch: async (fileID: string, batchID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileBatch', 'fileID', fileID)
            // verify required parameter 'batchID' is not null or undefined
            assertParamExists('getFileBatch', 'batchID', batchID)
            const localVarPath = `/files/{fileID}/batches/{batchID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)))
                .replace(`{${"batchID"}}`, encodeURIComponent(String(batchID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Batches on a File.
         * @summary Get Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileBatches: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileBatches', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/batches`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the details of an existing File using the unique File identifier that was returned upon creation.
         * @summary Retrieve File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByID: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileByID', 'fileID', fileID)
            const localVarPath = `/files/{fileID}`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
         * @summary Get File Contents
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileContents: async (fileID: string, xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('getFileContents', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/contents`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
         * @summary List Files
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (xRequestID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the ACH service is running.
         * @summary Ping ACH service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Split one File into two. One with only debits and one with only credits.
         * @summary Segment File
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {string} [body] ACH file (in Nacha or JSON formatting) along with optional segment configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentFile: async (xRequestID?: string, xIdempotencyKey?: string, body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/segment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Split one FileID into two. One with only debits and one with only credits.
         * @summary Segment FileID
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {any} [body] Optional configuration for segmenting files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentFileID: async (fileID: string, xRequestID?: string, xIdempotencyKey?: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('segmentFileID', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/segment`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['X-Idempotency-Key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File (Custom)
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {ValidateOpts} [validateOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFile: async (fileID: string, xRequestID?: string, validateOpts?: ValidateOpts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileID' is not null or undefined
            assertParamExists('validateFile', 'fileID', fileID)
            const localVarPath = `/files/{fileID}/validate`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRequestID !== undefined && xRequestID !== null) {
                localVarHeaderParameter['X-Request-ID'] = String(xRequestID);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateOpts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ACHFilesApi - functional programming interface
 * @export
 */
export const ACHFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ACHFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Append a Batch record to the specified File.
         * @summary Append Batch to File
         * @param {string} fileID File ID
         * @param {Batch} batch 
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addBatchToFile(fileID: string, batch: Batch, xRequestID?: string, xIdempotencyKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addBatchToFile(fileID, batch, xRequestID, xIdempotencyKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
         * @summary Build File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildFile(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkFile(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new File object from either the plaintext or JSON representation.
         * @summary Create File
         * @param {string} fileID File ID
         * @param {string} body Content of the ACH file (in json or raw text)
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {boolean} [requireABAOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassDestination] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customTraceNumbers] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowZeroBatches] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileHeader] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileControl] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [bypassCompanyIdentificationMatch] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customReturnCodes] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [unequalServiceClassCode] Optional parameter to configure ImmediateDestination validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFile(fileID: string, body: string, xRequestID?: string, xIdempotencyKey?: string, requireABAOrigin?: boolean, bypassOrigin?: boolean, bypassDestination?: boolean, customTraceNumbers?: boolean, allowZeroBatches?: boolean, allowMissingFileHeader?: boolean, allowMissingFileControl?: boolean, bypassCompanyIdentificationMatch?: boolean, customReturnCodes?: boolean, unequalServiceClassCode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFile(fileID, body, xRequestID, xIdempotencyKey, requireABAOrigin, bypassOrigin, bypassDestination, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a File and associated Batches. It cannot be undone.
         * @summary Delete File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteACHFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteACHFile(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a Batch from a File.
         * @summary Delete Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFileBatch(fileID, batchID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Consolidate Batches and Entries into the minimum number of Batches needed.
         * @summary Flatten Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flattenFile(fileID: string, xRequestID?: string, xIdempotencyKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlattenFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flattenFile(fileID, xRequestID, xIdempotencyKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a specific Batch on a File.
         * @summary Get Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Batch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileBatch(fileID, batchID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Batches on a File.
         * @summary Get Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileBatches(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Batch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileBatches(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the details of an existing File using the unique File identifier that was returned upon creation.
         * @summary Retrieve File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileByID(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileByID(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
         * @summary Get File Contents
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileContents(fileID: string, xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileContents(fileID, xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
         * @summary List Files
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(xRequestID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(xRequestID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if the ACH service is running.
         * @summary Ping ACH service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Split one File into two. One with only debits and one with only credits.
         * @summary Segment File
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {string} [body] ACH file (in Nacha or JSON formatting) along with optional segment configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentFile(xRequestID?: string, xIdempotencyKey?: string, body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentedFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentFile(xRequestID, xIdempotencyKey, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Split one FileID into two. One with only debits and one with only credits.
         * @summary Segment FileID
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {any} [body] Optional configuration for segmenting files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentFileID(fileID: string, xRequestID?: string, xIdempotencyKey?: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentedFiles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentFileID(fileID, xRequestID, xIdempotencyKey, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File (Custom)
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {ValidateOpts} [validateOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateFile(fileID: string, xRequestID?: string, validateOpts?: ValidateOpts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Error>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateFile(fileID, xRequestID, validateOpts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ACHFilesApi - factory interface
 * @export
 */
export const ACHFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ACHFilesApiFp(configuration)
    return {
        /**
         * Append a Batch record to the specified File.
         * @summary Append Batch to File
         * @param {string} fileID File ID
         * @param {Batch} batch 
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBatchToFile(fileID: string, batch: Batch, xRequestID?: string, xIdempotencyKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.addBatchToFile(fileID, batch, xRequestID, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
         * @summary Build File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFile(fileID: string, xRequestID?: string, options?: any): AxiosPromise<any> {
            return localVarFp.buildFile(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkFile(fileID: string, xRequestID?: string, options?: any): AxiosPromise<Error> {
            return localVarFp.checkFile(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new File object from either the plaintext or JSON representation.
         * @summary Create File
         * @param {string} fileID File ID
         * @param {string} body Content of the ACH file (in json or raw text)
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {boolean} [requireABAOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassOrigin] Optional parameter to configure ImmediateOrigin validation
         * @param {boolean} [bypassDestination] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customTraceNumbers] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowZeroBatches] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileHeader] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [allowMissingFileControl] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [bypassCompanyIdentificationMatch] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [customReturnCodes] Optional parameter to configure ImmediateDestination validation
         * @param {boolean} [unequalServiceClassCode] Optional parameter to configure ImmediateDestination validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFile(fileID: string, body: string, xRequestID?: string, xIdempotencyKey?: string, requireABAOrigin?: boolean, bypassOrigin?: boolean, bypassDestination?: boolean, customTraceNumbers?: boolean, allowZeroBatches?: boolean, allowMissingFileHeader?: boolean, allowMissingFileControl?: boolean, bypassCompanyIdentificationMatch?: boolean, customReturnCodes?: boolean, unequalServiceClassCode?: boolean, options?: any): AxiosPromise<CreateFileResponse> {
            return localVarFp.createFile(fileID, body, xRequestID, xIdempotencyKey, requireABAOrigin, bypassOrigin, bypassDestination, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a File and associated Batches. It cannot be undone.
         * @summary Delete File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteACHFile(fileID: string, xRequestID?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteACHFile(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Batch from a File.
         * @summary Delete Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFileBatch(fileID, batchID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Consolidate Batches and Entries into the minimum number of Batches needed.
         * @summary Flatten Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flattenFile(fileID: string, xRequestID?: string, xIdempotencyKey?: string, options?: any): AxiosPromise<FlattenFileResponse> {
            return localVarFp.flattenFile(fileID, xRequestID, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific Batch on a File.
         * @summary Get Batch
         * @param {string} fileID File ID
         * @param {string} batchID Batch ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: any): AxiosPromise<Batch> {
            return localVarFp.getFileBatch(fileID, batchID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Batches on a File.
         * @summary Get Batches
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileBatches(fileID: string, xRequestID?: string, options?: any): AxiosPromise<Array<Batch>> {
            return localVarFp.getFileBatches(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the details of an existing File using the unique File identifier that was returned upon creation.
         * @summary Retrieve File
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByID(fileID: string, xRequestID?: string, options?: any): AxiosPromise<any> {
            return localVarFp.getFileByID(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
         * @summary Get File Contents
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileContents(fileID: string, xRequestID?: string, options?: any): AxiosPromise<string> {
            return localVarFp.getFileContents(fileID, xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
         * @summary List Files
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(xRequestID?: string, options?: any): AxiosPromise<Array<any>> {
            return localVarFp.getFiles(xRequestID, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the ACH service is running.
         * @summary Ping ACH service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<void> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Split one File into two. One with only debits and one with only credits.
         * @summary Segment File
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {string} [body] ACH file (in Nacha or JSON formatting) along with optional segment configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentFile(xRequestID?: string, xIdempotencyKey?: string, body?: string, options?: any): AxiosPromise<SegmentedFiles> {
            return localVarFp.segmentFile(xRequestID, xIdempotencyKey, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Split one FileID into two. One with only debits and one with only credits.
         * @summary Segment FileID
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
         * @param {any} [body] Optional configuration for segmenting files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentFileID(fileID: string, xRequestID?: string, xIdempotencyKey?: string, body?: any, options?: any): AxiosPromise<SegmentedFiles> {
            return localVarFp.segmentFileID(fileID, xRequestID, xIdempotencyKey, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
         * @summary Validate File (Custom)
         * @param {string} fileID File ID
         * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
         * @param {ValidateOpts} [validateOpts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateFile(fileID: string, xRequestID?: string, validateOpts?: ValidateOpts, options?: any): AxiosPromise<Error> {
            return localVarFp.validateFile(fileID, xRequestID, validateOpts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ACHFilesApi - object-oriented interface
 * @export
 * @class ACHFilesApi
 * @extends {BaseAPI}
 */
export class ACHFilesApi extends BaseAPI {
    /**
     * Append a Batch record to the specified File.
     * @summary Append Batch to File
     * @param {string} fileID File ID
     * @param {Batch} batch 
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public addBatchToFile(fileID: string, batch: Batch, xRequestID?: string, xIdempotencyKey?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).addBatchToFile(fileID, batch, xRequestID, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns JSON formatted file. 
     * @summary Build File
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public buildFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).buildFile(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @summary Validate File
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public checkFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).checkFile(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new File object from either the plaintext or JSON representation.
     * @summary Create File
     * @param {string} fileID File ID
     * @param {string} body Content of the ACH file (in json or raw text)
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
     * @param {boolean} [requireABAOrigin] Optional parameter to configure ImmediateOrigin validation
     * @param {boolean} [bypassOrigin] Optional parameter to configure ImmediateOrigin validation
     * @param {boolean} [bypassDestination] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [customTraceNumbers] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [allowZeroBatches] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [allowMissingFileHeader] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [allowMissingFileControl] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [bypassCompanyIdentificationMatch] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [customReturnCodes] Optional parameter to configure ImmediateDestination validation
     * @param {boolean} [unequalServiceClassCode] Optional parameter to configure ImmediateDestination validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public createFile(fileID: string, body: string, xRequestID?: string, xIdempotencyKey?: string, requireABAOrigin?: boolean, bypassOrigin?: boolean, bypassDestination?: boolean, customTraceNumbers?: boolean, allowZeroBatches?: boolean, allowMissingFileHeader?: boolean, allowMissingFileControl?: boolean, bypassCompanyIdentificationMatch?: boolean, customReturnCodes?: boolean, unequalServiceClassCode?: boolean, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).createFile(fileID, body, xRequestID, xIdempotencyKey, requireABAOrigin, bypassOrigin, bypassDestination, customTraceNumbers, allowZeroBatches, allowMissingFileHeader, allowMissingFileControl, bypassCompanyIdentificationMatch, customReturnCodes, unequalServiceClassCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a File and associated Batches. It cannot be undone.
     * @summary Delete File
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public deleteACHFile(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).deleteACHFile(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Batch from a File.
     * @summary Delete Batch
     * @param {string} fileID File ID
     * @param {string} batchID Batch ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public deleteFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).deleteFileBatch(fileID, batchID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consolidate Batches and Entries into the minimum number of Batches needed.
     * @summary Flatten Batches
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public flattenFile(fileID: string, xRequestID?: string, xIdempotencyKey?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).flattenFile(fileID, xRequestID, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific Batch on a File.
     * @summary Get Batch
     * @param {string} fileID File ID
     * @param {string} batchID Batch ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public getFileBatch(fileID: string, batchID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).getFileBatch(fileID, batchID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Batches on a File.
     * @summary Get Batches
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public getFileBatches(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).getFileBatches(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the details of an existing File using the unique File identifier that was returned upon creation.
     * @summary Retrieve File
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public getFileByID(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).getFileByID(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assembles the existing File (batches and controls) records, computes sequence numbers and totals. Returns plaintext file. 
     * @summary Get File Contents
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public getFileContents(fileID: string, xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).getFileContents(fileID, xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ACH Files created with the ACH service. These Files are not persisted through multiple runs of the service.
     * @summary List Files
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public getFiles(xRequestID?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).getFiles(xRequestID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the ACH service is running.
     * @summary Ping ACH service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public ping(options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Split one File into two. One with only debits and one with only credits.
     * @summary Segment File
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
     * @param {string} [body] ACH file (in Nacha or JSON formatting) along with optional segment configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public segmentFile(xRequestID?: string, xIdempotencyKey?: string, body?: string, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).segmentFile(xRequestID, xIdempotencyKey, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Split one FileID into two. One with only debits and one with only credits.
     * @summary Segment FileID
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {string} [xIdempotencyKey] Idempotent key in the header which expires after 24 hours. These strings should contain enough entropy to not collide with each other in your requests.
     * @param {any} [body] Optional configuration for segmenting files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public segmentFileID(fileID: string, xRequestID?: string, xIdempotencyKey?: string, body?: any, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).segmentFileID(fileID, xRequestID, xIdempotencyKey, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the existing File. You need only supply the unique File identifier that was returned upon creation.
     * @summary Validate File (Custom)
     * @param {string} fileID File ID
     * @param {string} [xRequestID] Optional Request ID allows application developer to trace requests through the system\&#39;s logs
     * @param {ValidateOpts} [validateOpts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ACHFilesApi
     */
    public validateFile(fileID: string, xRequestID?: string, validateOpts?: ValidateOpts, options?: AxiosRequestConfig) {
        return ACHFilesApiFp(this.configuration).validateFile(fileID, xRequestID, validateOpts, options).then((request) => request(this.axios, this.basePath));
    }
}


